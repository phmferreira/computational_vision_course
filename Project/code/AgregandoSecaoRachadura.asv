%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%% Visão Computacional %%%%%%%%%%%%%%%%%%%
%%%%%%%% Projeto 2 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%% Aluno: Paulo Henrique Muniz Ferreira %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Algoritmo agregação de seções de rachaduras
% Descrição na subseção 4.2 do artigo de ref.

% ### Explicação (do que eu entendi) #######
%
% é usado um limiar para separar 
% e-seção (rachaduras expostas) 
% do plano de fundo (background)
% porém é usado o NDHM - Método do histograma das diferenças entre
% vizinhança
% (mas não está bem claro como fazer)

function ImagemBinarizada = AgregandoSecaoRachadura(Imagem)

% Toy problem
% Imagem = [1 2 5 6; 7 4 1 6; 3 5 1 3; 9 7 2 1];

% Figura do exemplo 3
exemplo1 = imread('imagens\ex2_NDHM','png'); % Abre a imagem
Imagem = rgb2gray(exemplo1);

% H <- é o histograma das diferenças
%%%%% (abscissas - valor do nível de cinza)
%%%%% (ordenadas - valor acumulado das diferenças)
% I_D <- Matriz correspondente a matriz da diferença de cada pixel
[H, I_D]  = NDHM(Imagem);

imhist(Imagem);
bar(H);
plot(H);

% Operação de Limiarização
% Melhores detalhes dessa etapa na seção 4 de [17] do artigo ref. 

ImagemBinarizada = binarizacao(H, Imagem);

% Salvando imagem binarizada
imshow(ImagemBinarizada);
% saveas(imagem, 'matriz_x_chapeu.jpg', 'jpg');



%%--------- FIM -------------%%

% #############################################################%
% ##### Seção Funções Auxiliares ####
% #############################################################%

% neighboring difference histogram method ref. [17] no artigo de ref.
function [H, I_D]  = NDHM(Imagem)

row = size(Imagem,1);
col = size(Imagem,2);

H = zeros(1,256);
I_D = zeros(row,col);

% For para calcular a diferença entre os vizinhos do pixel (i,j)
for i = 1:row
    for j = 1:col
        %%%
        if(Imagem(i,j) + 1 == 150)
            teste = 0;
        end
        I_D(i,j) = psi_chapeu(i,j, Imagem);
        %%%
        H(Imagem(i,j) + 1) = H(Imagem(i,j) + 1) + I_D(i,j);
    end % end_for colunas da imagem
end % end_for linhas da imagem

% calcula a função (4) do artigo de ref.
function psi_normalizado = psi_chapeu(i,j, Imagem)

psi_normalizado = 0;

% Calcular somatório das diferenças 
psi = somatorio_diferenca(i,j,Imagem);

for a = -1:1
    if (i + a > 0 &&  i + a <= size(Imagem,1))
        for b = -1:1
            if (j + b > 0 &&  j + b <= size(Imagem,2))
                if( ~(a == 0 && b == 0)) % condição remover pixel (i,j)
                    
                    % somatório das diferenças normalizado
                    % evita ruído sal-e-pimenta (speckle noise)
                    
                    p_0 = cast(Imagem(i, j),'double');
                    p_j = cast(Imagem(i + a, j + b),'double');
                    
                    sigma = (p_j - p_0)/psi;
                    
                    psi_normalizado = psi_normalizado ...
                        + (p_j - p_0)*sigma;
                    
                end % end_if
            end % end_if condição de coluna (dentro da imagem)
        end % end_for colunas da vizinhança
    end % end_if condição de linha (dentro da imagem)
end % end_for linhas da vizinhança

%psi_normalizado = psi_normalizado/(psi);

if(psi_normalizado == Inf)
    parar = 1;
    psi_normalizado = 0;
elseif(isnan(psi_normalizado))
    parar = 2;
end

function psi = somatorio_diferenca(i,j,Imagem)

psi = 0;

for a = -1:1
    if (i + a > 0 &&  i + a <= size(Imagem,1))
        for b = -1:1
            if (j + b > 0 &&  j + b <= size(Imagem,2))
                if( ~(a == 0 && b == 0)) % condição remover pixel (i,j)
                    
                    % somatório das diferenças
                    psi = psi + (cast(Imagem(i + a, j + b),'double') ...
                        - cast(Imagem(i, j),'double'));
                    
                end % end_if
            end % end_if condição de coluna (dentro da imagem)
        end % end_for colunas da vizinhança
    end % end_if condição de linha (dentro da imagem)
end % end_for linhas da vizinhança

if (psi == 0)
    parar = 1;
end

function I_B = binarizacao(H, Imagem)

row = size(Imagem,1);
col = size(Imagem,2);

I_B = zeros(row, col);
% É escolhido o t (nível de cinza) que 
% tem maior valor no Histograma (de diferenças)

[M, t] = max(H);

for i = 1:row
    for j = 1:col
        if(Imagem(i,j) <= (t-1))
            I_B(i,j) = 1;
        else
            I_B(i,j) = 0;
        end %end_if condição de binarização
    end %end_for colunas
end % end_for linhas


